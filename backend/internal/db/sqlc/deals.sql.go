// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: deals.sql

package db

import (
	"context"
	"database/sql"
)

const getDealsByAward = `-- name: GetDealsByAward :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE awarded = $1
ORDER BY closed_at
LIMIT $2
OFFSET $3
`

type GetDealsByAwardParams struct {
	Awarded bool
	Limit   int32
	Offset  int32
}

func (q *Queries) GetDealsByAward(ctx context.Context, arg GetDealsByAwardParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByAwardStmt, getDealsByAward, arg.Awarded, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByCustomerAndService = `-- name: GetDealsByCustomerAndService :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE service_to_render = $1 
AND customer_name = $2
ORDER BY id
LIMIT $3
OFFSET $4
`

type GetDealsByCustomerAndServiceParams struct {
	ServiceToRender string
	CustomerName    string
	Limit           int32
	Offset          int32
}

func (q *Queries) GetDealsByCustomerAndService(ctx context.Context, arg GetDealsByCustomerAndServiceParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByCustomerAndServiceStmt, getDealsByCustomerAndService,
		arg.ServiceToRender,
		arg.CustomerName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByCustomerName = `-- name: GetDealsByCustomerName :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE customer_name = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type GetDealsByCustomerNameParams struct {
	CustomerName string
	Limit        int32
	Offset       int32
}

func (q *Queries) GetDealsByCustomerName(ctx context.Context, arg GetDealsByCustomerNameParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByCustomerNameStmt, getDealsByCustomerName, arg.CustomerName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByProfit = `-- name: GetDealsByProfit :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE profit >= $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type GetDealsByProfitParams struct {
	Profit sql.NullString
	Limit  int32
	Offset int32
}

func (q *Queries) GetDealsByProfit(ctx context.Context, arg GetDealsByProfitParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByProfitStmt, getDealsByProfit, arg.Profit, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsBySalesRep = `-- name: GetDealsBySalesRep :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE sales_rep_name = $1
ORDER BY id 
LIMIT $2
OFFSET $3
`

type GetDealsBySalesRepParams struct {
	SalesRepName string
	Limit        int32
	Offset       int32
}

func (q *Queries) GetDealsBySalesRep(ctx context.Context, arg GetDealsBySalesRepParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsBySalesRepStmt, getDealsBySalesRep, arg.SalesRepName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsBySalesRepAndAwarded = `-- name: GetDealsBySalesRepAndAwarded :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE sales_rep_name = $1
AND awarded = $2
ORDER BY id 
LIMIT $3
OFFSET $4
`

type GetDealsBySalesRepAndAwardedParams struct {
	SalesRepName string
	Awarded      bool
	Limit        int32
	Offset       int32
}

func (q *Queries) GetDealsBySalesRepAndAwarded(ctx context.Context, arg GetDealsBySalesRepAndAwardedParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsBySalesRepAndAwardedStmt, getDealsBySalesRepAndAwarded,
		arg.SalesRepName,
		arg.Awarded,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByServicesRendered = `-- name: GetDealsByServicesRendered :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals 
WHERE service_to_render = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type GetDealsByServicesRenderedParams struct {
	ServiceToRender string
	Limit           int32
	Offset          int32
}

func (q *Queries) GetDealsByServicesRendered(ctx context.Context, arg GetDealsByServicesRenderedParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByServicesRenderedStmt, getDealsByServicesRendered, arg.ServiceToRender, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByStatus = `-- name: GetDealsByStatus :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE status = $1
ORDER BY id
`

func (q *Queries) GetDealsByStatus(ctx context.Context, status string) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByStatusStmt, getDealsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
