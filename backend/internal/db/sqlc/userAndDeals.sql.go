// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: userAndDeals.sql

package db

import (
	"context"
	"database/sql"
)

const countFilteredDeals = `-- name: CountFilteredDeals :one
SELECT COUNT(*)
FROM deals
WHERE 
    (customer_name ILIKE $1 OR $1 IS NULL) AND
    (service_to_render ILIKE $2 OR $2 IS NULL) AND
    (status = $3 OR $3 IS NULL) AND
    (profit >= $4 OR $4 IS NULL) AND
    (profit <= $5 OR $5 IS NULL) AND
    (awarded = $6 OR $6 IS NULL) AND
    (sales_rep_name ILIKE $7 OR $7 IS NULL)
`

type CountFilteredDealsParams struct {
	CustomerName    string
	ServiceToRender string
	Status          string
	Profit          sql.NullString
	Profit_2        sql.NullString
	Awarded         bool
	SalesRepName    string
}

func (q *Queries) CountFilteredDeals(ctx context.Context, arg CountFilteredDealsParams) (int64, error) {
	row := q.queryRow(ctx, q.countFilteredDealsStmt, countFilteredDeals,
		arg.CustomerName,
		arg.ServiceToRender,
		arg.Status,
		arg.Profit,
		arg.Profit_2,
		arg.Awarded,
		arg.SalesRepName,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterDeals = `-- name: FilterDeals :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE 
    (customer_name ILIKE $1 OR $1 IS NULL) AND
    (service_to_render ILIKE $2 OR $2 IS NULL) AND
    (status = $3 OR $3 IS NULL) AND
    (profit >= $4 OR $4 IS NULL) AND
    (profit <= $5 OR $5 IS NULL) AND
    (awarded = $6 OR $6 IS NULL) AND
    (sales_rep_name ILIKE $7 OR $7 IS NULL)
ORDER BY id 
LIMIT $8
OFFSET $9
`

type FilterDealsParams struct {
	CustomerName    string
	ServiceToRender string
	Status          string
	Profit          sql.NullString
	Profit_2        sql.NullString
	Awarded         bool
	SalesRepName    string
	Limit           int32
	Offset          int32
}

func (q *Queries) FilterDeals(ctx context.Context, arg FilterDealsParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.filterDealsStmt, filterDeals,
		arg.CustomerName,
		arg.ServiceToRender,
		arg.Status,
		arg.Profit,
		arg.Profit_2,
		arg.Awarded,
		arg.SalesRepName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsBySalesRep = `-- name: GetDealsBySalesRep :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE sales_rep_name = $1
ORDER BY id 
LIMIT $2
OFFSET $3
`

type GetDealsBySalesRepParams struct {
	SalesRepName string
	Limit        int32
	Offset       int32
}

func (q *Queries) GetDealsBySalesRep(ctx context.Context, arg GetDealsBySalesRepParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsBySalesRepStmt, getDealsBySalesRep, arg.SalesRepName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByStatus = `-- name: GetDealsByStatus :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE status = $1
ORDER BY id
`

func (q *Queries) GetDealsByStatus(ctx context.Context, status string) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByStatusStmt, getDealsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, username, role, full_name, email, password, password_changed, updated_at, created_at FROM users
WHERE username = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Role,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.PasswordChanged,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
