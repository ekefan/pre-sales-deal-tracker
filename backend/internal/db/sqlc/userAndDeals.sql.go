// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: userAndDeals.sql

package db

import (
	"context"
)

const countFilteredDeals = `-- name: CountFilteredDeals :one
WITH params AS (
    SELECT
        $1::TEXT AS customer_name,
        $2::TEXT AS service_to_render,
        $3::TEXT AS status,
        $4::NUMERIC AS min_profit,
        $5::NUMERIC AS max_profit,
        $6::BOOLEAN AS awarded,
        $7::TEXT AS sales_rep_name
)
SELECT COUNT(*) FROM deals
WHERE 
    (customer_name = (SELECT customer_name FROM params) OR (SELECT customer_name FROM params) IS NULL) AND
    (service_to_render = (SELECT service_to_render FROM params) OR (SELECT service_to_render FROM params) IS NULL) AND
    (status = (SELECT status FROM params) OR (SELECT status FROM params) IS NULL) AND
    (profit >= (SELECT min_profit FROM params) OR (SELECT min_profit FROM params) IS NULL) AND
    (profit <= (SELECT max_profit FROM params) OR (SELECT max_profit FROM params) IS NULL) AND
    (awarded = (SELECT awarded FROM params) OR (SELECT awarded FROM params) IS NULL) AND
    (sales_rep_name = (SELECT sales_rep_name FROM params) OR (SELECT sales_rep_name FROM params) IS NULL)
`

type CountFilteredDealsParams struct {
	Column1 *string
	Column2 *string
	Column3 *string
	Column4 *string
	Column5 *string
	Column6 *bool
	Column7 *string
}

func (q *Queries) CountFilteredDeals(ctx context.Context, arg CountFilteredDealsParams) (int64, error) {
	row := q.queryRow(ctx, q.countFilteredDealsStmt, countFilteredDeals,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterDeals = `-- name: FilterDeals :many
WITH params AS (
    SELECT
        $1::TEXT AS customer_name,
        $2::TEXT AS service_to_render,
        $3::TEXT AS status,
        $4::NUMERIC AS min_profit,
        $5::NUMERIC AS max_profit,
        $6::BOOLEAN AS awarded,
        $7::TEXT AS sales_rep_name
)
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE 
    (customer_name = (SELECT customer_name FROM params) OR (SELECT customer_name FROM params) IS NULL) AND
    (service_to_render = (SELECT service_to_render FROM params) OR (SELECT service_to_render FROM params) IS NULL) AND
    (status = (SELECT status FROM params) OR (SELECT status FROM params) IS NULL) AND
    (profit >= (SELECT min_profit FROM params) OR (SELECT min_profit FROM params) IS NULL) AND
    (profit <= (SELECT max_profit FROM params) OR (SELECT max_profit FROM params) IS NULL) AND
    (awarded = (SELECT awarded FROM params) OR (SELECT awarded FROM params) IS NULL) AND
    (sales_rep_name = (SELECT sales_rep_name FROM params) OR (SELECT sales_rep_name FROM params) IS NULL)
ORDER BY id
LIMIT $8
OFFSET $9
`

type FilterDealsParams struct {
	Column1 *string
	Column2 *string
	Column3 *string
	Column4 *string
	Column5 *string
	Column6 *bool
	Column7 *string
	Limit   int32
	Offset  int32
}

func (q *Queries) FilterDeals(ctx context.Context, arg FilterDealsParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.filterDealsStmt, filterDeals,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsBySalesRep = `-- name: GetDealsBySalesRep :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE sales_rep_name = $1
ORDER BY id 
LIMIT $2
OFFSET $3
`

type GetDealsBySalesRepParams struct {
	SalesRepName string
	Limit        int32
	Offset       int32
}

func (q *Queries) GetDealsBySalesRep(ctx context.Context, arg GetDealsBySalesRepParams) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsBySalesRepStmt, getDealsBySalesRep, arg.SalesRepName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByStatus = `-- name: GetDealsByStatus :many
SELECT id, pitch_id, sales_rep_name, customer_name, service_to_render, status, status_tag, current_pitch_request, net_total_cost, profit, created_at, updated_at, closed_at, awarded FROM deals
WHERE status = $1
ORDER BY id
`

func (q *Queries) GetDealsByStatus(ctx context.Context, status string) ([]Deal, error) {
	rows, err := q.query(ctx, q.getDealsByStatusStmt, getDealsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.PitchID,
			&i.SalesRepName,
			&i.CustomerName,
			&i.ServiceToRender,
			&i.Status,
			&i.StatusTag,
			&i.CurrentPitchRequest,
			&i.NetTotalCost,
			&i.Profit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Awarded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, username, role, full_name, email, password, password_changed, updated_at, created_at FROM users
WHERE username = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Role,
		&i.FullName,
		&i.Email,
		&i.Password,
		&i.PasswordChanged,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
